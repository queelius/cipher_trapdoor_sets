/*****
 * 
 * Anything that models a cipher type should have a hash(x)
 * function so that they may be composed.
 * 
 * For intance, if I have an x of type cipher_string that models a cipher
 * type, then hash(x) is defined.
 * 
 * Now, I can construct a set of these in various ways. One is to just do
 * the xor thing described elsewhere but of this approach only permits
 * equality and union operations... I could also make a cipher set that
 * permits contains queries using the cipher map model. This cipher map model
 * will take a vector of cipher_string and make a cipher set. However, if
 * each plaintext element x of type X maps to a set of cipher_string
 * representations, for homophonic encryption for instance, then only having
 * individual representations is not enough, but the cipher map may be
 * still constructed if the cipher_string generator is available. So,
 * we iterate through the strings in the set A of type 2^string, map them to
 * values of type cipher_string, then iterate over each cipher_string
 * to get all the representations for each, and then generate the cipher
 * map (or cipher set), e.g., cipher_set<cipher_string> which has a predicate
 * bool contains : cipher_set<cipher_string> -> cipher_string -> cipher_bool.
 * 
 * Should cipher_string be cipher<string>? probably, now its a monad of sorts.
 * we're lifting it.
 * 
 * 
 * the trapdoor is interesting. i think almost all cipher values can be
 * modeled as this. the cipher_set<cipher_string> has a to_hash() function
 * also, for instance, and now we can, for instance, generate
 * a cipher_set<cipher_set<cipher_string>> by taking a list of
 * cipher_set<cipher_string> and making it.
 * 
 * however, now we see again, that such a cipher_set<cipher_set<cipher_string>>
 * value, given two independent such sets, will have either the same or diff.
 * representations. if same rep, then we have the frequency / correlation
 * problem as before, but we can treat it like a normal cipher_set.
 * 
 * if each cipher_set is also a random variable a priori, then having a
 * particular realization of a cipher_set<cipher_string> as the elements
 * of cipher_set<cipher_set<cipher_string>> is incomplete. as before, though,
 * if we have the generators and the secret, we could in theory make *all*
 * such cipher_sets for a given cipher_set<cipher_string>... but there could
 * be *many* such representations (even countably infinite many, unless rate
 * distortion is imposed). 
 */


#pragma once

#include <string_view>
#include <functional>
using std::string_view;

/**
 * trapdoor<X> is a regular type.
 *
 * A trapdoor of X is a one-way transformation of values of type X
 * to trapdoor<X>. Let the one-way transformation be denoted by
 *     make_trapdoor : {0,1}^* -> X -> trapdoor<X>,
 * where the first argumen is a secret key.
 * 
 * Then, the partial application
 *     T(x) := \x -> make_trapdoor(s,x)
 * is of type X -> trapdoor<X>.
 * 
 * T is one-way in two independent senses:
 * 
 *     (1) T is easy to compute, but its "inverse" U : trapdoor<X> -> 2^X
 *         is (generally) hard.
 * 
 *     (2) Since T is (generally) non-invertible, U(t) := { x in X | T(x) = t }
 *         and thus each t in trapdoor<X> may map to multiple values in X.
 *
 *         In many cases, such as when X is a the free semigroup of a finite alphabet,
 *         U(t) is countably infinite for any t in trapdoor<X>. Thus, revealing
 *         which values U(t) maps to may not be very informative.
 * 
 * Note that trapdoor<X> is an *approximate cipher value type* since the value
 * of a t of type trapdoor<X> is difficult, if not impossible, to decipher
 * to its objective value of type X.
 * 
 * Furthermore, since == : trapdoor<X> -> trapdoor<X> -> bool (and its
 * complement) can be trivially defined (note that a cipher map could be
 * separately constructed for == which is not approximate), trapdoor<X>
 * is an *approximate* value type with respect to == and !=.
 * 
 * 
 * Few operations for this type can be defined on the basis of the hash
 * values alone. Cipher maps may be used to operate on these trapdoors more
 * generally, but they require access to the preimage hash values, i.e.,
 * either they require U(t) (which is expensive and is not one-to-one) or
 * the cipher maps were generated by someone who has access to the secret.
 * 
 * 
 */



template <typename X>
struct trapdoor
{
    using value_type = X;

    static constexpr auto VALUE_BYTE_LENGTH = sizeof(value_hash);
    static constexpr auto VALUE_BIT_LENGTH = CHAR_BIT * VALUE_BYTE_LENGTH;

    auto & operator=(trapdoor const & rhs)
    {
        value_hash = rhs.value_hash;
        key_hash = rhs.key_hash;
    }

    size_t value_hash;

    // the key hash is a hash of the secret key,
    // which faciliates a form of dynamic type checking.
    size_t key_hash;
};

template <
    typename X,
    template <typename> typename H = std::hash
>
auto make_trapdoor(
    X const & x,
    string_view k)
{
    return trapdoor<X>{x,H<std::string_view>{}(k)};
}


namespace std
{
    template <typename X>    
    struct hash<trapdoor<X>>
    {
        size_t operator()(trapdoor<X> const & x)
        {
            return x.value_hash;
        }
    }
}


/**
 * Given a shared secret, the random error on equality on trapdoor<X>, which is
 * a simple one-way substitution cipher where representational equality implies
 * equality, follows a second-order, positive Bernoulli model over Boolean
 * values with a false positive rate
 *     2^-bit_length(trapdoor<X>::hash_value).
 * 
 * Proof:
 * 
 * Suppose we have two objects of type X, denoted by A and B, where X is a
 * regular type such that A == B => hash(A) == hash(B).
 * 
 * Suppose A == B. Then, by definition, hash(A) == hash(B) and thus
 * trapdoor<X>{A} and trapdoor<X>{B} have the same representation where
 * representational equality implies equality. Thus,
 *     P[trapdoor<X>{A} == trapdoor<X>{B} | A == B] = 1.
 * 
 * Suppose A != B. Assume the hash function models a random hash function.
 * Since there are 2^bit-length(trapdoor<X>::hash_value) possible bit patterns
 * in the hashes of A and B, the probability that hash(A) and hash(B) collide is
 *     2^-bit-length(trapdoor<X>::hash_value).
 * Thus,
 *     P[trapdoor<X>{A} == trapdoor<X>{B} | A != B] =
 *         2^-bit_length(trapdoor<X>::hash_value).
 * 
 * Taking the two probabilities above together, we see that the true equality
 * is true, the probability of error is 0, and when the true equality is false,
 * the probability of error is 2^-bit_length(trapdoor<X>::hash_value).
 */
template <typename X>
auto operator==(trapdoor<X> const & x, trapdoor<X> const & y)
{
    return bernoulli<bool,2>
    {
        // realized value; may be erroneous
        x.value_hash == y.value_hash && x.key_hash == y.key_hash,
        // if truely true, then expected error is 0
        0.,
        // if truely false, then expected error is 2^-k where k is bit
        // length of hash value. (we ignore collisions on the secret.)
        std::pow(2.,-(double)trapdoor<X>::HASH_VALUE_BIT_LENGTH)
    };
}

template <typename X>
bool operator!=(trapdoor<X> const & x, trapdoor<X> const & y)
{
    return !(x == y);
}

