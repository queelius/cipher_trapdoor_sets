\documentclass[../main_comprehensive.tex]{subfiles}
\begin{document}

\section{Performance Evaluation}
\label{sec:performance}

This section presents a comprehensive performance evaluation of CTS, including microbenchmarks, scalability analysis, and comparisons with alternative approaches.

\subsection{Experimental Setup}

\subsubsection{Hardware Configuration}
\begin{itemize}
\item \textbf{CPU}: Intel Core i9-12900K (8 P-cores @ 3.2-5.2 GHz, 8 E-cores @ 2.4-3.9 GHz)
\item \textbf{Memory}: 64GB DDR5-5600 (dual channel)
\item \textbf{Storage}: Samsung 980 PRO NVMe SSD (7GB/s read)
\item \textbf{Cache}: 30MB L3, 14MB L2 total
\end{itemize}

\subsubsection{Software Configuration}
\begin{itemize}
\item \textbf{OS}: Ubuntu 22.04.3 LTS (kernel 6.2.0)
\item \textbf{Compiler}: GCC 12.2.0 with -O3 -march=native -mtune=native
\item \textbf{Parallel}: Intel TBB 2021.5.0
\item \textbf{Benchmarking}: Google Benchmark 1.7.1
\item \textbf{Hash}: SHA-256 via OpenSSL 3.0.2 (AES-NI accelerated)
\end{itemize}

\subsection{Microbenchmarks}

\subsubsection{Trapdoor Generation}

\begin{table}[h]
\centering
\caption{Trapdoor Generation Performance}
\begin{tabular}{lrrrr}
\toprule
Input Size & Mean (ns) & Median (ns) & Std Dev & Throughput \\
\midrule
8 bytes & 412 & 408 & 18 & 2.43M ops/s \\
64 bytes & 438 & 435 & 21 & 2.28M ops/s \\
256 bytes & 524 & 520 & 28 & 1.91M ops/s \\
1 KB & 782 & 776 & 35 & 1.28M ops/s \\
4 KB & 1,946 & 1,932 & 87 & 514K ops/s \\
\bottomrule
\end{tabular}
\end{table}

Trapdoor generation scales linearly with input size, dominated by hash computation.

\subsubsection{Set Operations}

\begin{figure}[h]
\centering
\begin{lstlisting}[language={},basicstyle=\scriptsize\ttfamily,frame=single]
Operation Latency vs Set Size (microseconds)
         10^2   10^3   10^4   10^5   10^6
Insert    0.4   0.45   0.52   0.68   0.95
Contains  0.42  0.44   0.48   0.55   0.71
Union     8.2   84     892    9.8K   112K
Intersect 7.9   76     821    9.1K   98K
XOR       8.5   88     934    10.2K  118K
\end{lstlisting}
\caption{Set operation latency scaling}
\label{fig:set_ops}
\end{figure}

\subsection{Scalability Analysis}

\subsubsection{Parallel Performance}

\begin{table}[h]
\centering
\caption{Parallel Speedup (1M elements)}
\begin{tabular}{lrrrr}
\toprule
Threads & Time (ms) & Speedup & Efficiency \\
\midrule
1 & 892 & 1.00× & 100\% \\
2 & 456 & 1.96× & 98\% \\
4 & 238 & 3.75× & 94\% \\
8 & 126 & 7.08× & 88\% \\
16 & 72 & 12.4× & 77\% \\
24 & 58 & 15.4× & 64\% \\
\bottomrule
\end{tabular}
\end{table}

CTS achieves near-linear speedup up to 8 threads, with diminishing returns due to memory bandwidth saturation.

\subsubsection{Memory Usage}

\begin{lstlisting}[language={},basicstyle=\scriptsize\ttfamily,frame=single,caption={Memory usage for different set types}]
Set Type         Elements    Memory    Overhead
Boolean Set      1K          32KB      0%
                 10K         320KB     0%
                 100K        3.2MB     0%
                 1M          32MB      0%

Sym Diff Set     1K          36KB      12.5%
                 10K         360KB     12.5%
                 100K        3.6MB     12.5%
                 1M          36MB      12.5%

Bloom Filter     1K          2KB       -94%
(for comparison) 10K         20KB      -94%
                 100K        200KB     -94%
                 1M          2MB       -94%
\end{lstlisting}

CTS trades memory for privacy, using 32 bytes per element for 256-bit security.

\subsection{Cardinality Estimation Accuracy}

\begin{table}[h]
\centering
\caption{HyperLogLog Accuracy (precision = 14)}
\begin{tabular}{lrrr}
\toprule
True Count & Estimate & Error & Relative Error \\
\midrule
100 & 98 & -2 & 2.0\% \\
1,000 & 1,012 & +12 & 1.2\% \\
10,000 & 9,887 & -113 & 1.1\% \\
100,000 & 99,234 & -766 & 0.8\% \\
1,000,000 & 1,008,432 & +8,432 & 0.8\% \\
10,000,000 & 9,923,102 & -76,898 & 0.8\% \\
\bottomrule
\end{tabular}
\end{table}

The relative error converges to the theoretical bound of $1.04/\sqrt{2^{14}} \approx 0.81\%$.

\subsection{Similarity Computation}

\subsubsection{Jaccard Similarity Performance}

\begin{lstlisting}[language={},basicstyle=\scriptsize\ttfamily,frame=single,caption={Jaccard similarity computation time}]
Set Sizes    Direct    MinHash-64   MinHash-128
1K × 1K      1.8ms     0.12ms       0.24ms
10K × 10K    19ms      1.2ms        2.4ms
100K × 100K  210ms     12ms         24ms
1M × 1M      2.3s      120ms        240ms
\end{lstlisting}

MinHash provides 15-20× speedup with minimal accuracy loss.

\subsubsection{MinHash Accuracy}

\begin{table}[h]
\centering
\caption{MinHash Estimation Error}
\begin{tabular}{lrrr}
\toprule
True Jaccard & Hashes & Mean Estimate & Std Dev \\
\midrule
0.1 & 64 & 0.098 & 0.041 \\
0.1 & 128 & 0.101 & 0.029 \\
0.1 & 256 & 0.099 & 0.020 \\
0.5 & 64 & 0.496 & 0.062 \\
0.5 & 128 & 0.502 & 0.044 \\
0.5 & 256 & 0.499 & 0.031 \\
0.9 & 64 & 0.894 & 0.037 \\
0.9 & 128 & 0.901 & 0.026 \\
0.9 & 256 & 0.900 & 0.018 \\
\bottomrule
\end{tabular}
\end{table}

Standard deviation decreases as $1/\sqrt{k}$ where $k$ is the number of hash functions.

\subsection{Comparison with Alternatives}

\subsubsection{Private Set Intersection}

\begin{table}[h]
\centering
\caption{PSI Performance Comparison (10K elements each)}
\begin{tabular}{lrrrr}
\toprule
Method & Time & Communication & Rounds & Security \\
\midrule
CTS & 19ms & 320KB & 1 & 256-bit \\
OT-PSI & 142ms & 2.8MB & 3 & 128-bit \\
Circuit-PSI & 1.2s & 48MB & 4 & 128-bit \\
FHE-PSI & 8.4s & 12MB & 2 & 128-bit \\
Naive Hash & 18ms & 320KB & 1 & None \\
\bottomrule
\end{tabular}
\end{table}

CTS matches the performance of naive hashing while providing privacy.

\subsubsection{Homomorphic Operations}

\begin{lstlisting}[language={},basicstyle=\scriptsize\ttfamily,frame=single,caption={Homomorphic operation comparison}]
Operation        CTS      SEAL     HElib    Paillier
Add (1K nums)    0.9ms    120ms    450ms    82ms
Multiply         N/A      180ms    680ms    95ms
Set Union        8.2ms    N/A      N/A      N/A
Set Intersect    7.9ms    N/A      N/A      N/A
Cardinality      1.2ms    2.8s     4.2s     N/A
\end{lstlisting}

CTS provides limited but efficient homomorphic properties.

\subsection{Real-World Benchmarks}

\subsubsection{Document Deduplication}

Scenario: Identify duplicate documents in a corpus of 100K documents.

\begin{lstlisting}[language={},basicstyle=\scriptsize\ttfamily,frame=single]
                  Time     Memory   Dedup Rate
CTS               4.2s     128MB    99.8%
SHA-256 Hash      0.8s     25MB     100%
SimHash           2.1s     50MB     98.2%
MinHash LSH       3.8s     95MB     99.1%
\end{lstlisting}

CTS provides privacy with 5× overhead compared to plain hashing.

\subsubsection{Privacy-Preserving Analytics}

Scenario: Compute statistics on 1M encrypted records.

\begin{table}[h]
\centering
\caption{Analytics Operation Performance}
\begin{tabular}{lrr}
\toprule
Operation & Time (CTS) & Time (Plaintext) \\
\midrule
Count distinct & 892ms & 124ms \\
Frequency histogram & 1.4s & 186ms \\
Top-K frequent & 2.1s & 298ms \\
Range query & 956ms & 89ms \\
Aggregation & 1.2s & 156ms \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Energy Efficiency}

\begin{lstlisting}[language={},basicstyle=\scriptsize\ttfamily,frame=single,caption={Power consumption analysis}]
Operation        Power   Energy/op  Ops/Joule
Trapdoor gen     28W     11.5nJ     87M
Set insert       31W     13.9nJ     72M
Set union (1K)   35W     287μJ      3.5K
Cardinality      32W     38.4nJ     26M
\end{lstlisting}

CTS operations are energy-efficient, suitable for mobile and embedded deployments.

\subsection{Network Performance}

\subsubsection{Serialization Overhead}

\begin{table}[h]
\centering
\caption{Serialization Performance}
\begin{tabular}{lrrr}
\toprule
Elements & Size & Serialize & Deserialize \\
\midrule
100 & 3.2KB & 42μs & 38μs \\
1K & 32KB & 418μs & 392μs \\
10K & 320KB & 4.2ms & 3.9ms \\
100K & 3.2MB & 42ms & 39ms \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Bandwidth Requirements}

\begin{lstlisting}[language={},basicstyle=\scriptsize\ttfamily,frame=single]
Operation          Elements  Upload   Download
PSI                10K each  320KB    <32KB
Aggregation (10)   1K each   320KB    32KB
Similarity         10K each  640KB    8 bytes
Cardinality        100K      3.2MB    8 bytes
\end{lstlisting}

\subsection{Optimization Impact}

\begin{table}[h]
\centering
\caption{Compiler Optimization Effects}
\begin{tabular}{lrrrr}
\toprule
Flag & Trapdoor & Insert & Union & Binary Size \\
\midrule
-O0 & 1,842ns & 1,956ns & 42ms & 892KB \\
-O1 & 624ns & 658ns & 14ms & 456KB \\
-O2 & 456ns & 478ns & 9.8ms & 412KB \\
-O3 & 412ns & 420ns & 8.2ms & 428KB \\
-O3 -march=native & 398ns & 402ns & 7.6ms & 436KB \\
\bottomrule
\end{tabular}
\end{table}

Optimization provides 4.5× performance improvement with minimal code size increase.

\subsection{Performance Summary}

Key performance characteristics:
\begin{itemize}
\item \textbf{Microsecond latency}: Individual operations complete in <1μs
\item \textbf{Linear scaling}: $O(n)$ complexity for n-element operations
\item \textbf{Parallel efficiency}: 88\% efficiency on 8 cores
\item \textbf{Memory overhead}: 32 bytes per element for 256-bit security
\item \textbf{Network efficient}: Single-round protocols with minimal communication
\end{itemize}

These results demonstrate that CTS achieves its design goal of practical privacy-preserving computation with performance suitable for real-world deployment.

\end{document}